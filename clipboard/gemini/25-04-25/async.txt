async function createZipFromHTMLs(htmls, titles, outputDir, baseName = "aula") {
    const zipFileName = `${baseName}_${Date.now()}.zip`;
    const effectiveOutputDir = (typeof outputDir === 'string' && outputDir) ? outputDir : require('os').tmpdir();
    const outputPath = path.join(effectiveOutputDir, zipFileName);

    console.log(`createZipFromHTMLs: Tentando criar zip em: ${outputPath}`);

    // Envolve a lógica em Promise para lidar com streams e eventos
    return new Promise((resolve, reject) => {
        try {
            fs.ensureDirSync(effectiveOutputDir);
            const output = fs.createWriteStream(outputPath);
            const archive = archiver("zip", { zlib: { level: 9 } });

            // Handlers de eventos ANTES de iniciar o pipe/finalize
            output.on("close", () => {
                console.log(`createZipFromHTMLs: Arquivo zip criado com ${archive.pointer()} bytes totais: ${outputPath}`);
                resolve(outputPath); // Resolve a Promise com o caminho do arquivo
            });

            archive.on("warning", (err) => {
                if (err.code === 'ENOENT') {
                     console.warn('createZipFromHTMLs: Aviso do Archiver:', err);
                } else {
                     // Erro não crítico, mas rejeita a promise? Depende. Por segurança, sim.
                     console.error('createZipFromHTMLs: Erro/Aviso crítico do Archiver:', err);
                     reject(err);
                 }
            });

            archive.on("error", (err) => {
                console.error('createZipFromHTMLs: Erro fatal do Archiver:', err);
                reject(err); // Rejeita a Promise em caso de erro fatal
            });

            // Inicia o processo
            archive.pipe(output);

            if (!htmls || htmls.length === 0) {
                 console.warn("createZipFromHTMLs: Nenhum HTML para adicionar ao zip.");
                 const errorMsg = `Nenhum tópico válido foi processado ou encontrado.`;
                 archive.append(Buffer.from(errorMsg, 'utf8'), { name: 'ERRO_NENHUM_TOPICO.txt' });
            } else {
                htmls.forEach((html, index) => {
                    const title = titles && titles[index] ? titles[index] : `Topico_${index + 1}`;
                    const isErrorTitle = title.startsWith('Erro Tópico') || title.startsWith('Tópico Vazio');
                    const safeTitleBase = title.replace(/<[^>]+>/g, '');
                    const sanitizedTitle = safeTitleBase.replace(/[^a-z0-9_\-]/gi, '_').substring(0, 50) || `Topico_${index + 1}`;
                    let fileName = `${sanitizedTitle}.html`;

                    const isErrorHtml = !html || typeof html !== 'string' || html.length === 0 || html.startsWith('<');
                    if (isErrorHtml) {
                        const errorContent = isErrorHtml ? 'Conteúdo HTML inválido ou vazio' : 'Erro desconhecido';
                        const errorFileHtml = `<!DOCTYPE html><html><head><title>Erro</title></head><body><h1>Erro ao gerar conteúdo para ${Utils.escapeHtml(title)}</h1><div>${errorContent}</div></body></html>`;
                        archive.append(Buffer.from(errorFileHtml, 'utf8'), { name: fileName });
                    } else {
                        archive.append(Buffer.from(html, 'utf8'), { name: fileName });
                    }
                });
            } // Fim do else (htmls exists)

            // Finaliza o arquivo (essencial para disparar 'close')
            archive.finalize();

        } catch (error) { // Captura erros síncronos (ex: ensureDirSync, createWriteStream)
            console.error("createZipFromHTMLs: Erro ao iniciar a criação do arquivo zip:", error);
            reject(error); // Rejeita a Promise
        }
    }); // Fim da Promise
} // Fim de createZipFromHTMLs

// Exporta as funções
module.exports = {
  processarAula,
  createZipFromHTMLs,
}; // Ponto e vírgula final adicionado para conformidade